# 学习笔记
## 一、实现一个地图编辑器：
    1. 定义一个长度10000的一维数组（或100*100二维数组）
    2. 通过遍历数组每个值来绘制100*100大小的地图
    3. 监听鼠标的点击、移动、抬起事件，实现地图编辑（数组修改）
    4. 点击save按钮将修改后的数组存入本地缓存，再刷新可以记录修改

## 二、广度优先搜索实现寻路
    1. 定义一个数组作为队列集合，使用push()+shift()操作数组队列
    2. 把起点周围的上下左右的点加进集合中，上下左右点再变为新的起点，继续找新起点周围的点并加入集合以便于后续操作，不断重复直至找到目标点（此过程可用递归实现深度优先搜索，但是针对寻路-使用深度优先不如广度优先高效）
    3. 广度优先搜索实现寻路：定义数组-queue-使用push()+shift()

## 三、异步绘制广搜寻路路径（寻路过程可视化）
    1. 将广搜寻过的点标绿色
    2. 要看一步一步的寻找涂色过程借助异步函数promise/async实现

## 四、得到最终寻路路径（起点通向目标点的前驱点集合）——启用 map1.html
    1. 为方便操作使用table克隆map，可保证每次刷新页面时map和视图的初始干净
    2. 定义队列queue，队列中初始值是寻路起始点坐标start，
    3. 广度优先遍历（队列queue.shift()一一出队获取点的坐标值-寻路过程途径点，将每个点周围的8个点再一一执行insertQueue函数入队-坐标值x,y作为参数）
    4. 在执行insertQueue时使用queue.push()入队；此外还需额外接收寻路过程的前驱点坐标作为参数，用来将前驱点坐标值赋给table数据结构中已寻过的位置上（标绿的点）
    5. 遍历过程中一旦遇到目标点end就可以终止遍历返回前驱点集合path了：定义path数组（用来写入各个前驱点的坐标），循环遍历table中各前驱点将坐标写入path将视图container中涂上粉色（通过将目标点上的标记值-它的前驱点坐标重新赋值给条件x和y，来实现不断获取上一个前驱点的循环过程）
    6. 细节修改五处：
        > 将直接对map数据结构中各值的操作改为在克隆体table上进行；
        > 将使用2来标记已寻过的table中位置改为使用前驱点pre来标记；
        > 将广度向周围四点的查找优化为周围八点（增加斜角四个点）；
        > 将path函数更名成findPath，path名被路径对象占用；
        > 将findPath返回值由true/false代表是否找到，改成path/null前驱点集合。

## 五、算法优化之启发式搜索——启用 map2.html
    1. 创建一个新的数据结构Sorted（take取出give放进）来代替队列queue（shift取出push放进）
        > 队列queue是只简单的按出入队顺序先进先出；
        > Sorted升级成按比较大小结果来先出队最小的值，进队正常。
    2. 保证take每次取出的永远是data中最小的那个值（扔掉最小的再取剩余最小的，循环重复）即可保证寻到的是更优路径。
    3. Sorted的参数data（原始数据）和compare（同数组的sort()方法,接收比较函数作为参数）都和Array数据结构保持一致
    4. 再说针对寻路算法而言的Sorted数据结构中，compare函数中是要获取到data所有值中到终点距离最小的那个值，所以要做的是距离的比较distance(a)-distance(b) ———— 通过一个函数distance计算出每个值坐标点到终点end的距离再比较距离的大小。
        > 函数distance：两坐标点之间的距离 = （两点x横坐标差值的平方+两点y轴纵坐标差值的平方）开根号
        > 因为此处结果是给compare用的，两个坐标间的距离都是大于1的，开不开根号比较结果都一样，所以可省去最后求平方根的步骤。
        > 这样的compare传入Sorted数据结构后，每次take取出来的就都是距离终点end最近的那个点，只扩展它们周围的节点，就可以得到一个相对笔直的更优寻路路径了。